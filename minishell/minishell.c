/**********************Mini ShellOperating Systems (Comp. Sci. 3473)Instructor: F. AllaireCompiled with gcc*********************This is a simple unix shell as outlined in the text*********************Many of the functions, such as fgets and strtok aredescribed in man pages**********************/#include <sys/types.h>#include <unistd.h>#include <stdio.h>#include <string.h>#include <stdlib.h>int main() {//Initialize	char command_line[512];	int status;	int x;	int background;	int pid, wpid;	char *argv[512];	//Main Loop	while(1) {//output prompt and input command		printf("\nminishell:>");		background=0;//	fflush(stdin);		fgets(command_line, 511, stdin);//		printf("length of command_line is %d\n", strlen(command_line));		if(strlen(command_line)>1)//strip carriage return and check for & at end		{			for(x=0; x<=511; x++)			{				if(command_line[x]==10)				{					//strip user's carriage return from end of command line					command_line[x]='\0';									if(command_line[x-1]=='&')					{	// end of command line was &, so set "Backbround Process" flag						command_line[x-1]='\0';						background=1;					}					// and break out of the loop					break;				}			}//build the argument list			x=0;			//get first token (=parameter)			char * token = strtok( command_line, " " );			//continue extracting tokens until no more are left			while(token!=NULL)			{				argv[x] = token;				x++;				//prepare next token / parameter				token = strtok(NULL, " " );			}//check if user wishes to EXIT			if(strcasecmp(argv[0], "exit")==0)			{				//print exit message then bail				printf("Good bye\n");//				break;				goto alldone;			}//create new process			if((pid=fork()) == 0) { //This is the child				//Execute in the same environment as the parent				execvp(argv[0], argv); 			}			else {	//This is the parent				//wait for the child to terminate if necessary				printf ("Parent: background is %d\n", background);				if(background==0)				{					printf ("parent waiting for process %d \n", pid);					wpid = wait(&status);					printf ("wait returned %d\n", wpid);//						while (wpid |= pid)//						{//							wpid = wait(&status);//							printf ("wait returned %d\n", wpid);//						}				}			}		}	}	//Terminate the shellalldone:	return 0;}